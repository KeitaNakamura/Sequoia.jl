```@meta
CurrentModule = Marble
```

# Background grid

## Grid generation

In Marble.jl, background grid can be generated by [`generate_grid`](@ref) function.

```@docs
generate_grid
```

## How to use grid

The generated grid is actually the special type of `StructArray` (see [StructArrays.jl](https://github.com/JuliaArrays/StructArrays.jl) for basic usage of `StructArray`).

```@repl grid
using Marble
GridState = @NamedTuple{x::Vec{2,Float64}, v::Vec{2,Float64}, f::Vec{2,Float64}}
grid = generate_grid(GridState, 0.5, (0,3), (0,2))
```

So, each field defined in `GridState` is stored as individual array, but all field arrays are the same size.
For example, the field `x` has a special immutable array (`Lattice`) having node coordinates of grid

```@repl grid
grid.x
```

All other fields are created as [`SpArray`](@ref)s

```@repl grid
grid.v
```

To store the value into `SpArray`, we have to call `update_sparsity_pattern!` as explained in [`SpArray`](@ref).
However, it is not allowed when `SpArray`s are created by `generate_grid` function to avoid unexpected behaviors.

```@repl grid
Marble.update_sparsity_pattern!(grid.v, trues(blocksize(grid)))
```

As suggested in error message, this should be done by [`update!(::MPSpace, ::Grid, ::Particles)`](@ref)
function for [`MPSpace`](@ref). This is because the all sparsity patterns of `SpArray`s in `grid` are identical.
So, updating sparsity pattern of `grid.v` affects `grid.f`, which can lead unexpected behaviors.
If you really know what you are doing, you can force to update by `Marble.unsafe_update_sparsity_pattern!`.

```@repl grid
Marble.unsafe_update_sparsity_pattern!(grid.v, trues(blocksize(grid)));
grid.v
grid.f
```

## `SpArray`

`SpArray` is used for grid array generated by [`generate_grid`](@ref).

```@docs
SpArray
```
